/**
 * Edge Case Tests - Complex SQL Statements
 * Tests combining multiple features: CTEs, subqueries, window functions,
 * aggregates, comments, lambdas, complex expressions, etc.
 */
import { TestSuite } from './framework.js';

export const complexQueryTests: TestSuite = {
    name: 'Complex Query Edge Cases',
    tests: [
        {
            name: 'Kitchen sink query - CTEs, window functions, subqueries, comments, aggregates',
            input: `-- Master analytics query for customer lifetime value
/* Author: Data Team
   Version: 2.1
   Last Updated: 2024-12-20 */
with -- Define base CTEs
raw_events as ( -- Raw event stream
    select /* pull from partitioned table */
        user_id,
        event_type,
        event_timestamp,
        properties::string as props, -- JSON properties
        date_trunc('day', event_timestamp) as event_date
    from analytics.events
    where event_timestamp >= date '2024-01-01'
        and event_timestamp < current_timestamp()
        and event_type in ('purchase', 'view', 'cart_add', 'signup') -- key events
),
user_sessions as (
    select
        user_id,
        event_date,
        count(*) as total_events,
        count(distinct event_type) as unique_event_types,
        min(event_timestamp) as first_event,
        max(event_timestamp) as last_event,
        sum(case when event_type = 'purchase' then 1 else 0 end) as purchases,
        sum(case when event_type = 'view' then 1 else 0 end) as views
    from raw_events
    group by user_id, event_date
    having count(*) > 1 -- exclude single-event sessions
),
enriched_users as (
    select
        u.user_id,
        u.email,
        u.created_at as signup_date,
        coalesce(p.plan_name, 'free') as plan,
        -- Calculate tenure in days
        datediff(current_date(), u.created_at) as tenure_days,
        -- Nested subquery for lifetime stats
        (select sum(amount) from orders o where o.user_id = u.user_id and o.status = 'completed') as lifetime_value,
        (select count(*) from orders o where o.user_id = u.user_id) as total_orders
    from users u
    left join plans p on u.plan_id = p.id
    where u.status = 'active'
)
/* Main query starts here */
select
    -- User identification
    eu.user_id,
    eu.email,
    eu.plan,
    -- Engagement metrics
    count(distinct us.event_date) as active_days,
    sum(us.total_events) as total_events,
    avg(us.total_events) as avg_events_per_day,
    -- Purchase behavior
    sum(us.purchases) as total_purchases,
    sum(us.views) as total_views,
    round(sum(us.purchases) * 100.0 / nullif(sum(us.views), 0), 2) as conversion_rate,
    -- Lifetime value with tiers
    eu.lifetime_value,
    case
        when eu.lifetime_value >= 10000 then 'platinum'
        when eu.lifetime_value >= 5000 then 'gold'
        when eu.lifetime_value >= 1000 then 'silver'
        when eu.lifetime_value > 0 then 'bronze'
        else 'prospect'
    end as value_tier,
    -- Window functions for ranking and trends
    row_number() over (partition by eu.plan order by eu.lifetime_value desc) as plan_rank,
    dense_rank() over (order by eu.lifetime_value desc) as overall_rank,
    percent_rank() over (partition by eu.plan order by sum(us.total_events)) as engagement_percentile,
    lag(sum(us.total_events), 1) over (partition by eu.user_id order by min(us.event_date)) as prev_period_events,
    sum(eu.lifetime_value) over (partition by eu.plan order by eu.signup_date rows between unbounded preceding and current row) as cumulative_ltv,
    -- Complex array operations
    collect_list(distinct us.event_date) as active_dates,
    transform(collect_list(us.total_events), x -> x * 1.1) as adjusted_events,
    filter(collect_list(us.total_events), x -> x > 10) as high_activity_days,
    -- Aggregation over filtered subset
    count(*) filter (where us.purchases > 0) as purchase_sessions,
    avg(us.total_events) filter (where us.event_date >= date_sub(current_date(), 30)) as recent_avg
from enriched_users eu
inner join user_sessions us
    on eu.user_id = us.user_id
left join lateral (
    -- Get most recent session details
    select session_id, device_type, browser
    from sessions s
    where s.user_id = eu.user_id
    order by s.created_at desc
    limit 1
) latest_session
    on true
where
    eu.tenure_days >= 30 -- established users only
    and us.event_date >= date_sub(current_date(), 90) -- recent activity
    and not exists (
        select 1
        from user_blocks b
        where b.user_id = eu.user_id
            and b.block_type = 'analytics_exclude'
    )
group by
    eu.user_id,
    eu.email,
    eu.plan,
    eu.lifetime_value,
    eu.signup_date,
    eu.tenure_days
having
    sum(us.total_events) > 100
    and count(distinct us.event_date) >= 5
order by
    eu.lifetime_value desc nulls last,
    total_events desc
limit 1000`,
            expected: `-- Master analytics query for customer lifetime value
/* Author: Data Team
   Version: 2.1
   Last Updated: 2024-12-20 */
WITH -- Define base CTEs
raw_events AS ( -- Raw event stream
    SELECT /* pull from partitioned table */
         user_id
        ,event_type
        ,event_timestamp
        ,properties::STRING AS props -- JSON properties
        ,DATE_TRUNC('day', event_timestamp) AS event_date
    FROM analytics.events
    WHERE
        event_timestamp >= DATE '2024-01-01'
        AND event_timestamp < CURRENT_TIMESTAMP()
        AND event_type IN ('purchase', 'view', 'cart_add', 'signup') -- key events
)
,user_sessions AS (
    SELECT
         user_id
        ,event_date
        ,COUNT(*) AS total_events
        ,COUNT(DISTINCT event_type) AS unique_event_types
        ,MIN(event_timestamp) AS first_event
        ,MAX(event_timestamp) AS last_event
        ,SUM(CASE WHEN event_type = 'purchase' THEN 1 ELSE 0 END) AS purchases
        ,SUM(CASE WHEN event_type = 'view' THEN 1 ELSE 0 END) AS views
    FROM raw_events
    GROUP BY
         user_id
        ,event_date
    HAVING COUNT(*) > 1 -- exclude single-event sessions
)
,enriched_users AS (
    SELECT
         u.user_id
        ,u.email
        ,u.created_at AS signup_date
        ,COALESCE(p.plan_name, 'free') AS plan
        ,DATEDIFF(CURRENT_DATE(), u.created_at) AS tenure_days -- Calculate tenure in days
        ,(
            SELECT SUM(amount)
            FROM orders o
            WHERE
                o.user_id = u.user_id
                AND o.status = 'completed'
        ) AS lifetime_value
        ,(
            SELECT COUNT(*)
            FROM orders o
            WHERE o.user_id = u.user_id
        ) AS total_orders
    FROM users u
    LEFT JOIN plans p
        ON u.plan_id = p.id
    WHERE u.status = 'active'
)
/* Main query starts here */
SELECT
     eu.user_id -- User identification
    ,eu.email
    ,eu.plan
    ,COUNT(DISTINCT us.event_date) AS active_days -- Engagement metrics
    ,SUM(us.total_events) AS total_events
    ,AVG(us.total_events) AS avg_events_per_day
    ,SUM(us.purchases) AS total_purchases -- Purchase behavior
    ,SUM(us.views) AS total_views
    ,ROUND(SUM(us.purchases) * 100.0 / NULLIF(SUM(us.views), 0), 2) AS conversion_rate
    ,eu.lifetime_value -- Lifetime value with tiers
    ,CASE
        WHEN eu.lifetime_value >= 10000 THEN 'platinum'
        WHEN eu.lifetime_value >= 5000 THEN 'gold'
        WHEN eu.lifetime_value >= 1000 THEN 'silver'
        WHEN eu.lifetime_value > 0 THEN 'bronze'
        ELSE 'prospect'
     END AS value_tier
    ,ROW_NUMBER() OVER (PARTITION BY eu.plan ORDER BY eu.lifetime_value DESC) AS plan_rank -- Window functions for ranking and trends
    ,DENSE_RANK() OVER (ORDER BY eu.lifetime_value DESC) AS overall_rank
    ,PERCENT_RANK() OVER (PARTITION BY eu.plan ORDER BY SUM(us.total_events)) AS engagement_percentile
    ,LAG(SUM(us.total_events), 1) OVER (PARTITION BY eu.user_id ORDER BY MIN(us.event_date)) AS prev_period_events
    ,SUM(eu.lifetime_value) OVER (PARTITION BY eu.plan ORDER BY eu.signup_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_ltv
    ,COLLECT_LIST(DISTINCT us.event_date) AS active_dates -- Complex array operations
    ,TRANSFORM(COLLECT_LIST(us.total_events), x -> x * 1.1) AS adjusted_events
    ,FILTER(COLLECT_LIST(us.total_events), x -> x > 10) AS high_activity_days
    ,COUNT(*) FILTER (WHERE us.purchases > 0) AS purchase_sessions -- Aggregation over filtered subset
    ,AVG(us.total_events) FILTER (WHERE us.event_date >= DATE_SUB(CURRENT_DATE(), 30)) AS recent_avg
FROM enriched_users eu
INNER JOIN user_sessions us
    ON eu.user_id = us.user_id
LEFT JOIN LATERAL (
    SELECT
         session_id -- Get most recent session details
        ,device_type
        ,browser
    FROM sessions s
    WHERE s.user_id = eu.user_id
    ORDER BY s.created_at DESC
    LIMIT 1
) latest_session
    ON TRUE
WHERE
    eu.tenure_days >= 30 -- established users only
    AND us.event_date >= DATE_SUB(CURRENT_DATE(), 90) -- recent activity
    AND NOT EXISTS (
        SELECT 1
        FROM user_blocks b
        WHERE
            b.user_id = eu.user_id
            AND b.block_type = 'analytics_exclude'
    )
GROUP BY
     eu.user_id
    ,eu.email
    ,eu.plan
    ,eu.lifetime_value
    ,eu.signup_date
    ,eu.tenure_days
HAVING
    SUM(us.total_events) > 100
    AND COUNT(DISTINCT us.event_date) >= 5
ORDER BY
     eu.lifetime_value DESC NULLS LAST
    ,total_events DESC
LIMIT 1000`,
        },
    ],
};

export const nestedWindowFunctionTests: TestSuite = {
    name: 'Nested Window Functions',
    tests: [
        {
            name: 'Multiple window functions with different frame specs',
            input: `select
                id,
                value,
                sum(value) over (order by id rows between 2 preceding and current row) as rolling_sum,
                avg(value) over (partition by category order by id rows between unbounded preceding and current row) as cumulative_avg,
                first_value(value) over (partition by category order by id range between interval 1 day preceding and current row) as recent_first,
                nth_value(value, 2) over (partition by category order by id desc rows between unbounded preceding and unbounded following) as second_highest
            from metrics`,
            expected: `SELECT
     id
    ,value
    ,SUM(value) OVER (ORDER BY id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_sum
    ,AVG(value) OVER (PARTITION BY category ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_avg
    ,FIRST_VALUE(value) OVER (PARTITION BY category ORDER BY id RANGE BETWEEN INTERVAL 1 DAY PRECEDING AND CURRENT ROW) AS recent_first
    ,NTH_VALUE(value, 2) OVER (PARTITION BY category ORDER BY id DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS second_highest
FROM metrics`,
        },
    ],
};

export const deeplyNestedSubqueriesTests: TestSuite = {
    name: 'Deeply Nested Subqueries',
    tests: [
        {
            name: 'Triple nested subquery with correlations',
            input: `select a.* from table_a a where a.value > (select avg(b.value) from table_b b where b.category = a.category and b.id in (select c.id from table_c c where c.status = (select max(d.status) from table_d d where d.type = b.type)))`,
            expected: `SELECT a.*
FROM table_a a
WHERE a.value > (
    SELECT AVG(b.value)
    FROM table_b b
    WHERE
        b.category = a.category
        AND b.id IN (
            SELECT c.id
            FROM table_c c
            WHERE c.status = (
                SELECT MAX(d.status)
                FROM table_d d
                WHERE d.type = b.type
            )
        )
)`,
        },
    ],
};

export const complexCteChainTests: TestSuite = {
    name: 'Complex CTE Chains',
    tests: [
        {
            name: 'Recursive CTE with complex base case',
            input: `with recursive hierarchy as (
                select id, parent_id, name, 1 as level, cast(id as string) as path
                from org_units
                where parent_id is null
                union all
                select o.id, o.parent_id, o.name, h.level + 1, concat(h.path, '/', o.id)
                from org_units o
                inner join hierarchy h on o.parent_id = h.id
                where h.level < 10
            )
            select * from hierarchy order by path`,
            expected: `WITH RECURSIVE hierarchy AS (
    SELECT
         id
        ,parent_id
        ,name
        ,1 AS level
        ,CAST(id AS STRING) AS path
    FROM org_units
    WHERE parent_id IS NULL
    UNION ALL
    SELECT
         o.id
        ,o.parent_id
        ,o.name
        ,h.level + 1
        ,CONCAT(h.path, '/', o.id)
    FROM org_units o
    INNER JOIN hierarchy h
        ON o.parent_id = h.id
    WHERE h.level < 10
)
SELECT *
FROM hierarchy
ORDER BY path`,
        },
    ],
};

export const complexExpressionTests: TestSuite = {
    name: 'Complex Expressions',
    tests: [
        {
            name: 'Nested CASE with subquery and window function',
            input: `select
                case
                    when status = 'active' then
                        case
                            when score > (select avg(score) from users) then 'high'
                            when score > 50 then 'medium'
                            else 'low'
                        end
                    when status = 'pending' then 'review'
                    else null
                end as tier,
                rank() over (partition by case when score > 100 then 'top' else 'regular' end order by score desc) as tier_rank
            from users`,
            expected: `SELECT
     CASE
        WHEN status = 'active' THEN
            CASE
                WHEN score > (
                    SELECT AVG(score)
                    FROM users
                ) THEN 'high'
                WHEN score > 50 THEN 'medium'
                ELSE 'low'
            END
        WHEN status = 'pending' THEN 'review'
        ELSE NULL
     END AS tier
    ,RANK() OVER (PARTITION BY CASE WHEN score > 100 THEN 'top' ELSE 'regular' END ORDER BY score DESC) AS tier_rank
FROM users`,
        },
        {
            name: 'Complex boolean with BETWEEN, LIKE, and IN',
            input: `select * from t where (a between 1 and 10 or b not between 20 and 30) and c like '%test%' escape '\\' and d not like 'prefix%' and e in (1, 2, 3) and f not in (select id from exclusions) and g is not null and h is distinct from i`,
            expected: `SELECT *
FROM t
WHERE
    (a BETWEEN 1 AND 10 OR b NOT BETWEEN 20 AND 30)
    AND c LIKE '%test%' ESCAPE '\\'
    AND d NOT LIKE 'prefix%'
    AND e IN (1, 2, 3)
    AND f NOT IN (
        SELECT id
        FROM exclusions
    )
    AND g IS NOT NULL
    AND h IS DISTINCT FROM i`,
        },
    ],
};

export const sparkAdvancedTests: TestSuite = {
    name: 'Spark Advanced Features',
    tests: [
        {
            name: 'Higher-order functions chain',
            input: `select
                transform(filter(array(1, 2, 3, 4, 5), x -> x > 2), y -> y * 2) as doubled_filtered,
                aggregate(array(1, 2, 3), 0, (acc, x) -> acc + x, acc -> acc * 10) as agg_result,
                exists(array(1, 2, 3), x -> x > 2) as has_large,
                forall(array(1, 2, 3), x -> x > 0) as all_positive,
                zip_with(array(1, 2), array(3, 4), (x, y) -> x + y) as zipped
            from dual`,
            expected: `SELECT
     TRANSFORM(FILTER(ARRAY(1, 2, 3, 4, 5), x -> x > 2), y -> y * 2) AS doubled_filtered
    ,AGGREGATE(ARRAY(1, 2, 3), 0, (acc, x) -> acc + x, acc -> acc * 10) AS agg_result
    ,EXISTS(ARRAY(1, 2, 3), x -> x > 2) AS has_large
    ,FORALL(ARRAY(1, 2, 3), x -> x > 0) AS all_positive
    ,ZIP_WITH(ARRAY(1, 2), ARRAY(3, 4), (x, y) -> x + y) AS zipped
FROM dual`,
        },
        {
            name: 'PIVOT with complex aggregation',
            input: `select * from (select region, quarter, revenue, costs from financials) pivot (sum(revenue) as rev, avg(costs) as cost for quarter in ('Q1' as q1, 'Q2' as q2, 'Q3' as q3, 'Q4' as q4))`,
            expected: `SELECT *
FROM (
    SELECT
         region
        ,quarter
        ,revenue
        ,costs
    FROM financials
) PIVOT (SUM(revenue) AS rev, AVG(costs) AS cost FOR quarter IN ('Q1' AS q1, 'Q2' AS q2, 'Q3' AS q3, 'Q4' AS q4))`,
        },
        {
            name: 'UNPIVOT transformation',
            input: `select * from sales_wide unpivot (amount for quarter in (q1_sales as 'Q1', q2_sales as 'Q2', q3_sales as 'Q3', q4_sales as 'Q4'))`,
            expected: `SELECT *
FROM sales_wide UNPIVOT (amount FOR quarter IN (q1_sales AS 'Q1', q2_sales AS 'Q2', q3_sales AS 'Q3', q4_sales AS 'Q4'))`,
        },
        {
            name: 'LATERAL VIEW with multiple explodes',
            input: `select t.id, item, idx, key, val from source_table t lateral view posexplode(items) exploded_items as idx, item lateral view explode(map_col) exploded_map as key, val`,
            expected: `SELECT
     t.id
    ,item
    ,idx
    ,key
    ,val
FROM source_table t LATERAL VIEW POSEXPLODE(items) exploded_items AS idx, item LATERAL VIEW EXPLODE(map_col) exploded_map AS key, val`,
        },
    ],
};

export const commentPlacementEdgeCasesTests: TestSuite = {
    name: 'Comment Placement Edge Cases',
    tests: [
        {
            name: 'Comments throughout complex query',
            input: `/* CTE block */
with -- first CTE
data as (
    select /* columns */
        a, -- col a
        b /* col b */
    from t -- source table
    where /* condition */ x = 1
)
-- Main query
select
    /* aggregates */
    sum(a) as total, -- total
    count(*) -- count
from data
group by b -- grouping
having total > 0 -- filter
order by total desc /* descending */`,
            expected: `/* CTE block */
WITH -- first CTE
data AS (
    SELECT /* columns */
         a -- col a
        ,b /* col b */
    FROM t -- source table
    WHERE /* condition */ x = 1
)
-- Main query
SELECT
     SUM(a) AS total /* aggregates */ -- total
    ,COUNT(*) -- count
FROM data
GROUP BY b -- grouping
HAVING total > 0 -- filter
ORDER BY total DESC /* descending */`,
        },
    ],
};

export const setOperationsComplexTests: TestSuite = {
    name: 'Complex Set Operations',
    tests: [
        {
            name: 'Chained set operations with subqueries',
            input: `(select a, b from t1 where x > 10)
            union all
            (select c, d from t2 where y < 5)
            except
            (select e, f from (select * from t3 where z = 1) sub)
            intersect
            (select g, h from t4)
            order by a
            limit 100`,
            expected: `(
    SELECT
         a
        ,b
    FROM t1
    WHERE x > 10
)
UNION ALL
(
    SELECT
         c
        ,d
    FROM t2
    WHERE y < 5
)
EXCEPT
(
    SELECT
         e
        ,f
    FROM (
        SELECT *
        FROM t3
        WHERE z = 1
    ) sub
)
INTERSECT
(
    SELECT
         g
        ,h
    FROM t4
)
ORDER BY a
LIMIT 100`,
        },
    ],
};

export const joinComplexTests: TestSuite = {
    name: 'Complex JOIN Scenarios',
    tests: [
        {
            name: 'Multiple join types with complex ON conditions',
            input: `select * from a
            inner join b on a.id = b.a_id and a.type = b.type
            left outer join c on b.id = c.b_id or (b.id is null and c.orphan = true)
            right join d on c.id = d.c_id
            full outer join e on d.id = e.d_id and e.status != 'deleted'
            cross join f
            left semi join g on a.id = g.a_id
            left anti join h on a.id = h.a_id
            where a.active = true`,
            expected: `SELECT *
FROM a
INNER JOIN b
    ON a.id = b.a_id
    AND a.type = b.type
LEFT OUTER JOIN c
    ON b.id = c.b_id
    OR (b.id IS NULL AND c.orphan = TRUE)
RIGHT JOIN d
    ON c.id = d.c_id
FULL OUTER JOIN e
    ON d.id = e.d_id
    AND e.status != 'deleted'
CROSS JOIN f
LEFT SEMI JOIN g
    ON a.id = g.a_id
LEFT ANTI JOIN h
    ON a.id = h.a_id
WHERE a.active = TRUE`,
        },
    ],
};

// Export all test suites
export const edgeCaseTestSuites = [
    complexQueryTests,
    nestedWindowFunctionTests,
    deeplyNestedSubqueriesTests,
    complexCteChainTests,
    complexExpressionTests,
    sparkAdvancedTests,
    commentPlacementEdgeCasesTests,
    setOperationsComplexTests,
    joinComplexTests,
];
