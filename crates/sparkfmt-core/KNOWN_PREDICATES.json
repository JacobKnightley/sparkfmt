{
  "description": "Catalog of semantic predicates in Spark SQL grammar. Used to detect new predicates when grammar is updated.",
  "version": "1.0.0",
  "grammar_source": "https://github.com/apache/spark/tree/master/sql/api/src/main/antlr4/org/apache/spark/sql/catalyst/parser",
  "last_updated": "2024-12-19",
  
  "lexer_predicates": {
    "methods": {
      "is_valid_decimal": {
        "original": "isValidDecimal()",
        "rust": "is_valid_decimal()",
        "description": "Check if current token forms a valid decimal number (not followed by dot for range syntax)",
        "return_type": "bool"
      },
      "is_hint": {
        "original": "isHint()",
        "rust": "is_hint()",
        "description": "Check if block comment is a query hint /*+ ... */",
        "return_type": "bool"
      },
      "is_shift_right_operator": {
        "original": "isShiftRightOperator()",
        "rust": "is_shift_right_operator()",
        "description": "Disambiguate >> as shift operator vs nested generic closing",
        "return_type": "bool"
      }
    },
    "actions": {
      "inc_complex_type_level_counter": {
        "original": "incComplexTypeLevelCounter()",
        "rust": "inc_complex_type_level_counter()",
        "description": "Increment counter for nested complex types (MAP, ARRAY, STRUCT)",
        "side_effect": true
      },
      "dec_complex_type_level_counter": {
        "original": "decComplexTypeLevelCounter()",
        "rust": "dec_complex_type_level_counter()",
        "description": "Decrement counter for nested complex types",
        "side_effect": true
      },
      "mark_unclosed_comment": {
        "original": "markUnclosedComment()",
        "rust": "mark_unclosed_comment()",
        "description": "Mark that an unclosed block comment was encountered for error reporting",
        "side_effect": true
      },
      "push_dollar_tag": {
        "original": "tags.push(getText())",
        "rust": "push_dollar_tag()",
        "description": "Push dollar-quoted string tag onto stack",
        "side_effect": true
      },
      "pop_dollar_tag": {
        "original": "tags.pop()",
        "rust": "pop_dollar_tag()",
        "description": "Pop dollar-quoted string tag from stack",
        "side_effect": true
      },
      "matches_dollar_tag": {
        "original": "getText().equals(tags.peek())",
        "rust": "matches_dollar_tag()",
        "description": "Check if current text matches the tag on top of stack",
        "return_type": "bool"
      }
    }
  },
  
  "parser_predicates": {
    "config_flags": {
      "legacy_setops_precedence_enabled": {
        "original": "legacySetopsPrecedenceEnabled",
        "rust": "legacy_setops_precedence_enabled",
        "description": "Use legacy precedence for set operations (UNION, EXCEPT, etc)",
        "type": "bool",
        "default": false
      },
      "sql_standard_keyword_behavior": {
        "original": "sqlStandardKeywordBehavior",
        "rust": "sql_standard_keyword_behavior",
        "description": "Use SQL standard keyword rules (stricter identifier restrictions)",
        "type": "bool",
        "default": false
      },
      "double_quoted_identifiers": {
        "original": "doubleQuotedIdentifiers",
        "rust": "double_quoted_identifiers",
        "description": "Treat double-quoted strings as identifiers (not string literals)",
        "type": "bool",
        "default": false
      },
      "parameter_substitution_enabled": {
        "original": "parameterSubstitutionEnabled",
        "rust": "parameter_substitution_enabled",
        "description": "Enable parameter marker substitution (?)",
        "type": "bool",
        "default": false
      },
      "legacy_exponent_literal_as_decimal_enabled": {
        "original": "legacyExponentLiteralAsDecimalEnabled",
        "rust": "legacy_exponent_literal_as_decimal_enabled",
        "description": "Parse exponent literals (1e10) as decimal instead of double",
        "type": "bool",
        "default": false
      },
      "legacy_identifier_clause_only": {
        "original": "legacyIdentifierClauseOnly",
        "rust": "legacy_identifier_clause_only",
        "description": "Restrict IDENTIFIER clause to legacy behavior",
        "type": "bool",
        "default": false
      }
    },
    "methods": {
      "is_operator_pipe_start": {
        "original": "isOperatorPipeStart()",
        "rust": "is_operator_pipe_start()",
        "description": "Check if |> pipe operator is starting (for operator precedence)",
        "return_type": "bool"
      }
    }
  }
}
